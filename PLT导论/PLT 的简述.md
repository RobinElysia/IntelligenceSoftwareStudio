## 什么是 PLT？

**编程语言理论**（英语：Programming language theory）是计算机科学的一个分支，研究编程语言的设计、实现、分析、描述和分类及其各自的特点。它属于计算机科学，既依赖又影响着数学、软件工程、语言学，甚至认知科学。

或者换句话说，这其实就是一门通用课程。了解完这门课程以后，几乎所有的编程语言其实都不再是难题。同时，我可能还会穿插部分操作系统设计原理、计算机组成原理和数据结构知识......

> 注：实际上很多东西都是在一起的，只不过计算机科学家为了方便我们学习，将其进行了划分。比如说，你能在 PLT 的正统课程（CS 242等课程）中能看到软件分析这部分内容，这部分内容中的并发编程其实是基于操作系统的并发来说的（PLT牵扯了OS Design）。
>
> 但总归是，我们的 PLT 不需要那么严谨的大纲，我会把每一次课程的内容就像这样整理成一份markdown 文档，各位可以根据回忆我说过的进行脑补。或者你们也可以写自己的md笔记文档，这样时间久了你们也会有一份自己的学习笔记。

## 我们的共识——状态机（state machine）

还记得么？我在你们第一见我的时候提到的状态机，我们今天需要重新介绍一下它——万物基于状态机。

与一些共识不同的是，你们在上 Java 课上一定提到了“万物皆对象”。没错，但是不完全对，因为这句话存在一些片面的东西，比如一切东西不一定都可以抽象为对象（或者说不合适抽象为对象，比如时间，时间可以被抽象为对象么？不太好作为对象），所以就有了这么一种合理的解释——“是一切符合xx条件的对象皆可以做什么”，这才是面向对象的真正精髓。***我们需要找一些可以进行对象化的东西，才可以合理编写面向对象，而不是一味的滥用！***

我为什么要提“万物皆对象”呢？因为它和“万物基于状态机”一致，事实上我们可以理解为“状态机”其实也是一种“对象”，只不过，我们考虑了时间这个概念。打个比方：存钱罐，你可以把这个存钱罐比作我们现在的机器。存钱罐的初始值是 _num = 0_，假如我们现在有钱，并尝试存入面值为 _n_ 的钱时，存钱罐会执行 _K1_ 这个 _num += n_ 的操作。你会发现在某一个特定的时刻 _Ti_，这个存钱罐的钱是确定的，并且这个存钱罐执行操作可以是 _+=、Reset_，由此我们就引出了这个概念——状态机  
 在上述例子中，我们可以知道存在这个几个关键，即：

OldState（旧状态）、Event（条件）、Transition（转换）、Action（新状态）  
它们分别对应着：  
_num = 0（旧状态）_、_我有 n 钱（条件）_、_+=（转换）_、_num += n（新状态）_

这就是状态机，你发现了么？事实上“万物基于状态机”这句话并没有错，因为我们存在的世界就是一个基于时间的世界，所有的东西都在向前走，周而复始，状态变化。所有的一切都可以抽象为状态机！

而我们为什么要提及状态机？是因为***我们今天看到的计算机就是一个状态机！***，它的硬件、软件（操作系统、程序运行的进程）都是状态机！

### 硬件

你们见过闹钟，闹钟是由机械结构组成的机器，在某种程度上讲闹钟也是一种状态机；你们可能见过辉光管，他也是一种状态机，在某个时间有某个时钟；你们也可能见过工厂里的数控机床，设置好的程序步骤在进行作业...

这些硬件结构都可以是状态机，基于时间的改变有不同的状态。同样的，我们的计算机也是状态机。还记得么？我们曾了解过CPU时钟周期概念，我说：“衡量一个CPU性能的基本准则是看它在一个指令周期的执行指令个数”，其中一个指令周期是一次脉冲，也就是时间标准下的状态改变、CPU的性能准则基于单位时间下的指令执行速度。CPU是状态机！那其他的呢？内存、硬盘、显卡等等等等，它们同样的在某一时刻在处理/传输数据，它们都是状态机！

### 操作系统

在硬件之上，我们并非直接就能运行程序。我们都知道操作系统的作用是提供给用户的一种方便操作的系统（不然怎么叫操作系统呢？），但是在早期的电脑上，是没有操作系统的，所有的程序直接运行在硬件之上，程序的编写十分困难，几乎到了写一个程序需要同时和所有硬件打交道的地步，为了隔离硬件与程序方便开发，我们有了操作系统！

操作系统干了什么事？他把硬件的一些功能（接口）进行了封装和简化，并将优化后的功能（接口）提供给上层的程序编写者/程序员，让程序员能直接使用这些功能（接口）调用硬件。开发成本大幅降低，我们不用在捧着400多页的英特尔CPU手册发愁，转而面向操作系统提供的接口进行编程。

那么，操作系统是状态机么？是的，因为操作系统是软件，软件由代码编写。还记么我交给你们的代码调试（debug），你可以给代码加断点，在某一时刻，这个运行的代码有一个状态（你能看到变量的值变化）。这不就是状态机么？

OS 是状态机的管理者，同样本身也是状态机

### 程序运行的进程

需要区分一下我们说的这些东西：

1. 计算机硬件（状态机）
2. 计算机软件（状态机）
   1. 操作系统（状态机）
   2. 程序（状态机的静态描述）
      1. 程序运行的进程（状态机）
         为什么我标记了程序是状态机的静态描述呢？比如说，你下载的QQ，在你不运行它的时候，它就是一段冰冷的代码，没有任何状态，就像是世界按下了暂停键。而进程是程序运行的实例，比如你可以打开多个QQ，每一个QQ进程都是一个状态机实例。

这就是关于什么是计算机的全部！

## 计算机是怎么运行程序的？

我们第二个至关重要的话题，计算机是怎么运行程序的？好吧，我知道各位对此一知半解，甚至可能会说“双击运行”这样的小白级别的回答。
我们今天的话题就是关于这个的，在开始之前，让我们稍稍来回忆一下计算机的硬件和软件......

### 信息是怎么在硬件当中传输的？

先来说说计算机硬件，我们之前就提到过，关于数据的存储设备，比如“硬盘”、“内存”、“缓存”、“寄存器”这些，它们之间是如何做到数据传递的？这值得我们探究。
首先，当我们点击一个程序的时候，鼠标/键盘会发送中断信号到操作系统内核，操作系统内核接收到后会通知硬件们进行协调并希望能对程序进行初始化，其中CPU 开始执行第一条指令却找不到物理页（真实数据），于是CPU硬件触发缺页异常，为了处理这个异常，操作系统内核（最核心的代码）通知硬盘进行数据读取，数据传输到了内存把缺失的数据填满，之后进入main，开始交错进行读取（缺页、读取数据、缺页、读取数据...）
![[_- visual selection.png]]
这其中有很多问题，比如：

1. 操作系统内核是什么？
   1. 模块化设计思想
2. 鼠标/键盘的中断信号是什么？
3. 内核是如何协调硬件的？
4. 什么是缺页异常？Core Dump，Segmentation Fault
5. 内核通知完硬盘后？是如何将数据传递到内存的？
   1. 硬盘是什么读取数据的？
   2. 内存是怎么存储数据的？
6. 主程序初始化后，在内存中长什么样子？
   1. https://blog.csdn.net/qq_28249373/article/details/76768776
7. 怎么交错运行？它到底有什么值得我们去学习的（取指译码）？

对于这些问题，我们都可以进行AI或者浏览器搜索，但是，毕竟是我在授课么，所以这个任务就交给我了。

1. 操作系统内核（Kernel）是操作系统最核心的部分，它负责管理计算机的硬件资源，并为应用程序提供基础服务。可以把内核看作是操作系统与硬件之间的桥梁，它直接运行在硬件之上，控制和管理着系统的各种资源。
2. 鼠标/键盘的中断信号是一种外部设备的“介入”信号，比如说，现在我的鼠标在移动，那么在移动的时候，这些设备会主动发送中断到计算机，告诉计算机，我现在有操作，你接收一下，接收到了信息后，操作系统内核会进行处理。
3. 内核先让硬件自己喊中断（发起中断），把 CPU 抓过来；接着拿锁把并发切成串行（串行），读寄存器或拉 DMA 把数据搬进内存（存数据）；再把不同设备的裸数据套进统一的结构里（结构化）；最后通过系统调用递给进程，硬件就算被它哄服帖了（传递给进程）。
4. 缺页异常是Fast and slow path的一种实现，我们打开一个文件/程序的时候，并不是直接打开的，而是先触发缺页异常（类似懒加载机制），然后将真正的数据加载进来。
5. 硬盘：
6. 内存：

### 汇编与指令集

你们老师绝对和你们提到过，关于计算机语言的发展，他大致是：

1. 机器语言（010101）
2. 汇编
3. 高级语言
   但是他不够全面，真正的层次结构应该是：
4. 机器语言（第一代语言）
   1. 01010101
5. 汇编语言（第二代语言）
   1. ADD R0 R1
   2. 一元操作符，
6. 高级语言（第三代语言）
   1. C/C++、Java、Python、Go、Rust...
7. 特定领域语言（第四代语言）
   1. SQL、MATLAB
8. 逻辑式 / 约束式 / 声明式语言（第五代语言）
   1. Prolog、Lisp、Lean、Wolfram Language
      这些层次中，最早的机器语言不必多说，关于汇编是我们需要有所了解，高级语言是我们正在学的，特定领域语言以后会学习，第五代语言则是PLT研究者正在钻研的（与人工智能相结合）。

现在，来让我们看看汇编吧。提及汇编那就不得不提指令集，可以这么说

```assembly
ADD R0 R1

R0 = 0
R1 = 1
或者
R1 = 0x0001 只想一块地址，地址指向的位置存储着数据 1
```

​	但是汇编是困难的，它的语义对于人类而言是非人类的，你可以想象一个从0到10累加的程序，汇编需要写将近50几行代码，并且这些代码的RX寄存器是不可读的，它和我们今天看到和使用的高级语言是不同的，高级语言可以自定义变量，我们可以使用变量来引用数据，但是汇编只有地址和寄存器，这也是为什么汇编没有流行，为什么有了后来的高级语言的原因

### C 语言的诞生

​	所以到了近代，计算机科学家丹尼斯里奇在贝尔实验室才搓出了C语言，并且与此同时，大型机专用操作系统Unix在这里诞生（Linux前前身）。C语言是一门面向过程的语言，他强调的是一个程序编写的流程，因为程序是顺序执行的，所以这很大程度上就是直觉。但是问题就在于，顺序执行在面对横向拓展的时候会出现问题，比如说买菜，按照循序执行，我们的逻辑肯定是先拿钱，再开门，骑车，买菜，但是如果这个过程中你还需要去接孩子，按照顺序流程你需要再次开门骑车么？答案是肯定的，这就是面向过程的一大缺陷。

​	但是我们的关注点不仅仅在设计理念上，还在语法结构上，你可以看到C语言的语法和你们学习的Java是类似的，他也有变量、运算符、操作符、布尔运算、判断结构、循环结构这些：

```C
#include <stdio.h>

int main() {
    // ================== 变量声明 ==================
    int i;                    // 循环计数器
    int number;               // 用户输入的数字
    int sum = 0;              // 存储累加和
    int positive_count = 0;   // 正数计数器
    int negative_count = 0;   // 负数计数器
    int count = 0;            // 有效数字计数器
    
    // ================== 运算符和操作符 ==================
    // 算术运算符: +, -, *, /, %
    // 赋值运算符: =, +=
    // 关系运算符: >, <, ==, !=, >=, <=
    // 逻辑运算符: &&, ||, !
    // 自增运算符: ++
    
    printf("请输入5个整数（输入0结束循环）:\n");
    
    // ================== 循环结构 (for循环) ==================
    for(i = 1; i <= 5; i++) {  // i++ 是自增操作符
        printf("请输入第%d个数字: ", i);
        scanf("%d", &number);   // & 是取地址操作符
        
        // ================== 判断结构 (if-else if-else) ==================
        if(number == 0) {
            printf("检测到0，提前结束循环\n");
            break;              // break 是控制流操作符
        }
        
        // ================== 布尔运算 ==================
        // 使用关系运算符和逻辑运算符进行布尔运算
        if(number > 0 && number < 100) {  // && 是逻辑与运算符
            positive_count++;   // 自增操作符
            printf("这是一个小于100的正数\n");
        } 
        else if(number > 0) {
            positive_count++;
            printf("这是一个大于等于100的正数\n");
        } 
        else if(number < 0) {
            negative_count++;
            printf("这是一个负数\n");
        }
        else {
            printf("这是零\n");
        }
        
        // ================== 复合赋值运算符 ==================
        sum += number;          // 等价于 sum = sum + number
        count++;
        
        // ================== 三目运算符（条件运算符） ==================
        char* type = (number % 2 == 0) ? "偶数" : "奇数";
        printf("这个数字是%s\n\n", type);
    }
    
    // ================== 计算平均值 ==================
    float average = 0.0;        // 浮点数变量
    if(count > 0) {
        // 类型转换操作符: (float)
        average = (float)sum / count;  // 强制类型转换
        
        // ================== 复杂布尔表达式 ==================
        if(average > 0 && (positive_count > negative_count || sum > 100)) {
            printf("平均值为正，且满足以下条件之一：\n");
            printf("1. 正数数量大于负数数量\n");
            printf("2. 总和大于100\n");
        }
    }
    
    // ================== 输出统计结果 ==================
    printf("\n========== 统计结果 ==========\n");
    printf("输入的有效数字个数: %d\n", count);
    printf("正数个数: %d\n", positive_count);
    printf("负数个数: %d\n", negative_count);
    printf("数字总和: %d\n", sum);
    printf("数字平均值: %.2f\n", average);
    
    // ================== 另一个循环结构 (while循环) ==================
    printf("\n使用while循环输出1到3:\n");
    int j = 1;                  // 初始化计数器
    while(j <= 3) {             // while循环，使用布尔表达式
        printf("j = %d\n", j);
        j++;                    // 自增操作符
    }
    
    // ================== do-while循环 ==================
    printf("\n使用do-while循环输出1到2:\n");
    int k = 1;
    do {
        printf("k = %d\n", k);
        k++;
    } while(k <= 2);            // 循环条件判断
    
    return 0;                   // return 是控制流操作符
}
```

​	除此以外，它还有哪些特点呢？指针！什么是指针？还记得我说过的内存地址么？

​	指针是C/C++的一大亮点，原因在于，指针能够十分方便的操作你能错做的每块内存上的数据，这就是它的有点所在。当然他的缺点也十分明显，直接和内存打交道风险极大，一不小心就会指针异常，这是每一个初学者都会遇到的问题！看看一个例子吧：

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 指针基础操作示例
void pointer_basic_example() {
    printf("=== 指针基础操作 ===\n");
    
    int num = 42;
    int *ptr = &num;  // ptr指向num的地址
    
    printf("1. 基本指针操作:\n");
    printf("   num的值: %d\n", num);
    printf("   num的地址: %p\n", &num);
    printf("   ptr存储的地址: %p\n", ptr);
    printf("   ptr指向的值: %d\n", *ptr);  // 解引用操作
    
    // 通过指针修改变量值
    *ptr = 100;
    printf("   通过*ptr修改后，num的值: %d\n\n", num);
    
    // 指针的指针
    int **pptr = &ptr;
    printf("2. 二级指针:\n");
    printf("   pptr存储的地址: %p\n", pptr);
    printf("   pptr指向的地址: %p\n", *pptr);
    printf("   pptr最终指向的值: %d\n\n", **pptr);
}
```

### 百家争鸣

#### C++

​	一个吸取了C语言的一些特点的语言，或者说，他是C语言的超集，你能直接在C++里写C的语法。C++到底是什么样的呢？它既可以写C的面向过程，还实现了面向工业解决的面向对象，没错就是你们知道的那个面向对象，面向对象是怎么样的？我们还是使用那个买菜的例子，问题在于面向过程需要重复实现出门和骑车，但是面向过程不需要，你只需要将这两个功能进行封装，提供一个接口，面向过程的工业实践就是这样，你直接调用接口就可以了，无需重复编写代码！这就是面向对象的有点。

​	但是为什么我们不学C++呢？因为学习难度…C++是公认难学的一门语言，你需要掌握的不仅是java难度的面向对象写法，还需要关注指针等系统/硬件级别的知识，这也是我们为什么有了Java的原因，因为Java没有这些…

​	来看一下C++：

```C
#include <iostream>
#include <vector>

int main() {
    // ========== 变量声明 ==========
    int score = 0;                // 整数变量
    double average = 0.0;         // 浮点数变量
    bool isPassing = false;       // 布尔变量
    std::vector<int> scores;      // 容器变量
    char choice = 'y';            // 字符变量
    
    // ========== 运算符和操作符 ==========
    std::cout << "请输入学生成绩（输入-1结束）：\n";
    
    // ========== 循环结构 ==========
    while (true) {
        int inputScore;
        std::cout << "成绩: ";
        std::cin >> inputScore;
        
        // ========== 判断结构 ==========
        if (inputScore == -1) {           // 关系运算符 ==
            break;                        // 退出循环
        }
        else if (inputScore < 0 || inputScore > 100) {  // 逻辑运算符 ||
            std::cout << "无效成绩！请输入0-100之间的数字。\n";
            continue;                     // 继续下一次循环
        }
        
        // ========== 操作符使用 ==========
        scores.push_back(inputScore);     // 成员操作符 .
        score += inputScore;              // 复合赋值运算符 +=
    }
    
    // ========== 布尔运算和判断结构 ==========
    if (!scores.empty()) {                // 逻辑运算符 !
        // ========== 运算符 ==========
        average = static_cast<double>(score) / scores.size();  // 类型转换操作符
        
        // ========== 关系运算符和逻辑运算符 ==========
        isPassing = (average >= 60.0) && (scores.size() >= 3);  // >= 和 &&
        
        std::cout << "\n========== 成绩统计 ==========\n";
        std::cout << "学生人数: " << scores.size() << std::endl;
        std::cout << "总成绩: " << score << std::endl;
        std::cout << "平均成绩: " << average << std::endl;
        
        // ========== 判断结构 ==========
        if (isPassing) {
            std::cout << "状态: 通过\n";
        } else {
            std::cout << "状态: 不通过\n";
            std::cout << "原因: ";
            
            // ========== 三元条件运算符 ==========
            std::cout << (average < 60.0 ? "平均分不足" : "考试次数不足") << std::endl;
        }
        
        // ========== 更多运算符示例 ==========
        int highest = scores[0];           // 下标操作符 []
        int lowest = scores[0];
        
        // ========== 循环结构（for循环） ==========
        for (size_t i = 1; i < scores.size(); i++) {  // 自增运算符 ++
            // ========== 关系运算符 ==========
            if (scores[i] > highest) {     // 关系运算符 >
                highest = scores[i];
            }
            if (scores[i] < lowest) {      // 关系运算符 <
                lowest = scores[i];
            }
        }
        
        std::cout << "最高分: " << highest << std::endl;
        std::cout << "最低分: " << lowest << std::endl;
        
        // ========== 位运算符示例 ==========
        unsigned int flags = 0;
        flags |= 0x01;  // 设置标志位，按位或运算符 |
        flags |= 0x04;
        
        if (flags & 0x01) {  // 按位与运算符 &
            std::cout << "标志位1已设置\n";
        }
    } else {
        std::cout << "没有输入任何成绩！\n";
    }
    
    // ========== 赋值运算符和算术运算符 ==========
    int x = 10, y = 3;
    int sum = x + y;      // 算术运算符 +
    int diff = x - y;     // 算术运算符 -
    int prod = x * y;     // 算术运算符 *
    int quot = x / y;     // 算术运算符 /
    int mod = x % y;      // 取模运算符 %
    
    std::cout << "\n========== 运算符示例 ==========\n";
    std::cout << "x + y = " << sum << std::endl;
    std::cout << "x - y = " << diff << std::endl;
    std::cout << "x * y = " << prod << std::endl;
    std::cout << "x / y = " << quot << std::endl;
    std::cout << "x % y = " << mod << std::endl;
    
    return 0;
}
```

#### Java

​	Java也被叫做C++ - -，确实是这样的，他砍掉了C++的一些困难遗留，比如指针

讲基础语法

#### Python

讲基础语法

