## 什么是 PLT？

**编程语言理论**（英语：Programming language theory）是计算机科学的一个分支，研究编程语言的设计、实现、分析、描述和分类及其各自的特点。它属于计算机科学，既依赖又影响着数学、软件工程、语言学，甚至认知科学。

或者换句话说，这其实就是一门通用课程。了解完这门课程以后，几乎所有的编程语言其实都不再是难题。同时，我可能还会穿插部分操作系统设计原理、计算机组成原理和数据结构知识......

> 注：实际上很多东西都是在一起的，只不过计算机科学家为了方便我们学习，将其进行了划分。比如说，你能在 PLT 的正统课程（CS 242等课程）中能看到软件分析这部分内容，这部分内容中的并发编程其实是基于操作系统的并发来说的（PLT牵扯了OS Design）。
> 
> 但总归是，我们的 PLT 不需要那么严谨的大纲，我会把每一次课程的内容就像这样整理成一份markdown文档，各位可以根据回忆我说过的进行脑补。或者你们也可以写自己的md笔记文档，这样时间久了你们也会有一份自己的学习笔记。

## 我们的共识——状态机
还记得么？我在你们第一见我的时候提到的状态机，我们今天需要重新介绍一下它——万物基于状态机。

与一些共识不同的是，你们在上Java课上一定提到了“万物皆对象”。没错，但是不完全对，因为这句话存在一些片面的东西，比如一切东西不一定都可以抽象为对象（或者说不合适抽象为对象，比如时间，时间可以被抽象为对象么？不太好作为对象），所以就有了这么一种合理的解释——“是一切符合xx条件的对象皆可以做什么”，这才是面向对象的真正精髓。***我们需要找一些可以进行对象化的东西，才可以合理编写面向对象，而不是一味的滥用！***

我为什么要提“万物皆对象”呢？因为它和“万物基于状态机”一致，事实上我们可以理解为“状态机”其实也是一种“对象”，只不过，我们考虑了时间这个概念。打个比方：存钱罐，你可以把这个存钱罐比作我们现在的机器。存钱罐的初始值是 _num = 0_，假如我们现在有钱，并尝试存入面值为 _n_ 的钱时，存钱罐会执行 _K1_ 这个 _num += n_ 的操作。你会发现在某一个特定的时刻 _Ti_，这个存钱罐的钱是确定的，并且这个存钱罐执行操作可以是 _+=、Reset_，由此我们就引出了这个概念——状态机  
 在上述例子中，我们可以知道存在这个几个关键，即：

OldState（旧状态）、Event（条件）、Transition（转换）、Action（新状态）  
它们分别对应着：  
_num = 0（旧状态）_、_我有 n 钱（条件）_、_+=（转换）_、_num += n（新状态）_

这就是状态机，你发现了么？事实上“万物基于状态机”这句话并没有错，因为我们存在的世界就是一个基于时间的世界，所有的东西都在向前走，周而复始，状态变化。所有的一切都可以抽象为状态机！

而我们为什么要提及状态机？是因为***我们今天看到的计算机就是一个状态机！***，它的硬件、软件（操作系统、程序运行的进程）都是状态机！

### 硬件
你们见过闹钟，闹钟是由机械结构组成的机器，在某种程度上讲闹钟也是一种状态机；你们可能见过辉光管，他也是一种状态机，在某个时间有某个时钟；你们也可能见过工厂里的数控机床，设置好的程序步骤在进行作业...

这些硬件结构都可以是状态机，基于时间的改变有不同的状态。同样的，我们的计算机也是状态机。还记得么？我们曾了解过CPU时钟周期概念，我说：“衡量一个CPU性能的基本准则是看它在一个指令周期的执行指令个数”，其中一个指令周期是一次脉冲，也就是时间标准下的状态改变、CPU的性能准则基于单位时间下的指令执行速度。CPU是状态机！那其他的呢？内存、硬盘、显卡等等等等，它们同样的在某一时刻在处理/传输数据，它们都是状态机！

### 操作系统
在硬件之上，我们并非直接就能运行程序。我们都知道操作系统的作用是提供给用户的一种方便操作的系统（不然怎么叫操作系统呢？），但是在早期的电脑上，是没有操作系统的，所有的程序直接运行在硬件之上，程序的编写十分困难，几乎到了写一个程序需要同时和所有硬件打交道的地步，为了隔离硬件与程序方便开发，我们有了操作系统！

操作系统干了什么事？他把硬件的一些功能（接口）进行了封装和简化，并将优化后的功能（接口）提供给上层的程序编写者/程序员，让程序员能直接使用这些功能（接口）调用硬件。开发成本大幅降低，我们不用在捧着400多页的英特尔CPU手册发愁，转而面向操作系统提供的接口进行编程。

那么，操作系统是状态机么？是的，因为操作系统是软件，软件由代码编写。还记么我交给你们的代码调试（debug），你可以给代码加断点，在某一时刻，这个运行的代码有一个状态（你能看到变量的值变化）。这不就是状态机么？

### 程序运行的进程
需要区分一下我们说的这些东西：
1. 计算机硬件（状态机）
2. 计算机软件（状态机）
	1. 操作系统（状态机）
	2. 程序（状态机的静态描述）
		1. 程序运行的进程（状态机）
为什么我标记了程序是状态机的静态描述呢？比如说，你下载的QQ，在你不运行它的时候，它就是一段冰冷的代码，没有任何状态，就像是世界按下了暂停键。而进程是程序运行的实例，比如你可以打开多个QQ，每一个QQ进程都是一个状态机实例。

这就是关于什么是计算机的全部！

## 计算机是怎么运行程序的？
我们第二个至关重要的话题，计算机是怎么运行程序的？好吧，我知道各位对此一知半解，甚至可能会说“双击运行”这样的小白级别的回答。
我们今天的话题就是关于这个的，在开始之前，让我们稍稍来回忆一下计算机的硬件和软件......

### 信息是怎么在硬件当中传输的？
先来说说计算机硬件，我们之前就提到过，关于数据的存储设备，比如“硬盘”、“内存”、“缓存”、“寄存器”这些，它们之间是如何做到数据传递的？这值得我们探究。
首先，当我们点击一个程序的时候，鼠标/键盘会发送中断信号到操作系统内核，操作系统内核接收到后会通知硬件们进行协调并希望能对程序进行初始化，其中CPU 开始执行第一条指令却找不到物理页（真实数据），于是CPU硬件触发缺页异常，为了处理这个异常，操作系统内核（最核心的代码）通知硬盘进行数据读取，数据传输到了内存把缺失的数据填满，之后进入main，开始交错进行读取（缺页、读取数据、缺页、读取数据...）
![[_- visual selection.png]]
这其中有很多问题，比如：
1. 操作系统内核是什么？
2. 鼠标/键盘的中断信号是什么？
3. 内核是如何协调硬件的？
4. 什么是缺页异常？
5. 内核通知完硬盘后？是如何将数据传递到内存的？
	1. 硬盘是什么读取数据的？
	2. 内存是怎么存储数据的？
6. 主程序初始化后，在内存中长什么样子？
7. 怎么交错运行？它到底有什么值得我们去学习的（取指译码）？

对于这些问题，我们都可以进行AI或者浏览器搜索，但是，毕竟是我在授课么，所以这个任务就交给我了。

1. 操作系统内核（Kernel）是操作系统最核心的部分，它负责管理计算机的硬件资源，并为应用程序提供基础服务。可以把内核看作是操作系统与硬件之间的桥梁，它直接运行在硬件之上，控制和管理着系统的各种资源。
2. 鼠标/键盘的中断信号是一种外部设备的“介入”信号，比如说，现在我的鼠标在移动，那么在移动的时候，这些设备会主动发送中断到计算机，告诉计算机，我现在有操作，你接收一下，接收到了信息后，操作系统内核会进行处理。
3. 内核先让硬件自己喊中断（发起中断），把 CPU 抓过来；接着拿锁把并发切成串行（串行），读寄存器或拉 DMA 把数据搬进内存（存数据）；再把不同设备的裸数据套进统一的结构里（结构化）；最后通过系统调用递给进程，硬件就算被它哄服帖了（传递给进程）。
4. 缺页异常是Fast and slow path的一种实现，我们打开一个文件/程序的时候，并不是直接打开的，而是先触发缺页异常（类似懒加载机制），然后将真正的数据加载进来。
5. 硬盘：
6. 内存：

### 汇编与指令集
你们老师绝对和你们提到过，关于计算机语言的发展，他大致是：
1. 机器语言（010101）
2. 汇编
3. 高级语言
但是他不够全面，真正的层次结构应该是：
4. 机器语言（第一代语言）
	1. 01010101
5. 汇编语言（第二代语言）
	1. ADD R0 R1
6. 高级语言（第三代语言）
	1. C/C++、Java、Python、Go、Rust...
7. 特定领域语言（第四代语言）
	1. SQL、MATLAB
8. 逻辑式 / 约束式 / 声明式语言（第五代语言）
	1. Prolog、Lisp、Lean、Wolfram Language
这些层次中，最早的机器语言不必多说，关于汇编是我们需要有所了解，高级语言是我们正在学的，特定领域语言以后会学习，第五代语言则是PLT研究者正在钻研的（与人工智能相结合）。

现在，来让我们看看汇编吧。提及汇编那就不得不提指令集，可以这么说

### C 语言的诞生

### 百家争鸣

#### C++

#### Java

#### Python

#### Rust

#### Go

#### 其他

## 